#' Site_parCI
#'
#' @name Site_parCI
#' @param atsite_temp
#' A vector or single column matrix of air temperature data subtracted (or not) by its sample mean.
#' @param model
#' A single interger number from 1 to 4 defining the GEV model.
#' May be provided by `best_model()`
#' @param site_par
#' A 5-column and 1-row `data.frame` or`matrix` as that generated by `best.parms()`.
#'  * 1st column is the mu0 parameter,
#'  * 2nd is the mu1 parameter,
#'  * 3rd is the sigma0 parameter,
#'  * 4th is the sigma1 parameter,
#'  * 5th is the shape parameter
#' @param n.boots
#' A single number describing the number of copies of the original data sample.
#' Whenever possible n.boots should be set to 999 (its default value),
#' as suggested by Burn (2003) <10.1623/hysj.48.1.25.43485> and
#' Oâ€™Brien and Burn (2014) <10.1016/j.jhydrol.2014.09.041>.
#' @return
#' A matrix containing the 95% confidence intervals (lower and upper bounds)
#' of the time-varying parameter estimates.
#' @export
#' @importFrom stats quantile
#' @importFrom spsUtil quiet
#' @importFrom extRemes fevd
#' @importFrom utils setTxtProgressBar txtProgressBar
#' @examplesIf interactive()
#' temperatures <- TmaxCPC_SP$Pixel_1
#' model <- 2
#' site_par <- Fit_model(temperatures, model)
#' Site_parCI(atsite_temp=temperatures,
#'            model=model,
#'            site_par=site_par[1:5],
#'            n.boots=100)
Site_parCI <- function(atsite_temp,model,site_par,n.boots){
  data_site <- as.matrix(atsite_temp)
  if (ncol(data_site) != 1) {stop("data_site must be a vector or single column matrix.")}
  if (is.null(n.boots)) {
    n.boots <- 999
  }
  if (n.boots < 100) {stop("n.boots must be larger than 99 and, if possible, equal to 999.")}
  max_time <- length(data_site)
  if (max_time < 10) {
    stop("Site must have at least 10 years of records. So sorry, we cannot proceed.")
  }
  # Check that site_par is numeric
  site_par <- as.matrix(site_par)
  if (!all(sapply(site_par, is.numeric))) {
    stop("Input 'reg_par' must be a numeric data frame or matrix with 5 columns.")
  }
  if (ncol(site_par) != 5 || nrow(site_par) != 1) {
    stop("Input 'site_par' must have exactly 1 row and 5 columns.")
  }
  site_par <- as.numeric(site_par)
  par.temporal <- matrix(NA,max_time,3)
  #scaled <- scale(1L:max_time)
  time <- (1L:max_time)
  IDD.series <- data_site
  par.temporal[,1] <- site_par[1] + site_par[2] * time
  par.temporal[,2] <- site_par[3] + site_par[4] * time
  par.temporal[,3] <-  rep(site_par[5],max_time)
  IDD.series <- 1/par.temporal[,3] * log( 1+ par.temporal[,3] * ((data_site-par.temporal[,1])/par.temporal[,2]))
  ##################
  all.lines <- n.boots * max_time
  # Preallocate matrix
  IDD.series.boot <- matrix(NA_real_, all.lines, 1)

  # Vectorized resampling
  IDD.series.boot <- as.vector(replicate(n.boots, sample(IDD.series, replace = TRUE)))

  # Preallocate matrices
  site_par.overall.boot <- matrix(NA_real_, n.boots, 5)
  message("This calculation may take a while.")
  pb <- txtProgressBar(min = 0, max = n.boots, style = 3)
  for (r in seq_len(n.boots)) {
    rows <- ((r - 1) * max_time + 1):(r * max_time)
    back.orig <- par.temporal[, 1] +
      (par.temporal[, 2] / par.temporal[, 3]) *
      (exp(IDD.series.boot[rows] * par.temporal[, 3]) - 1)
    parameters <- Fit_model(temperatures=back.orig,model=model)
    site_par.overall.boot[r,] <- as.matrix(parameters[1:5])
    setTxtProgressBar(pb, r)
  }
  close(pb)
  # Compute the 95% confidence intervals (row-wise quantiles)
  CI_lower <- apply(site_par.overall.boot, 2, quantile, probs = 0.025, na.rm = TRUE)
  CI_upper <- apply(site_par.overall.boot, 2, quantile, probs = 0.975, na.rm = TRUE)

  # Combine into a matrix for easy visualization
  CI_matrix <- rbind(CI_lower, CI_upper)
  rownames(CI_matrix) <- c("Lower 95% CI", "Upper 95% CI")
  colnames(CI_matrix) <- c("mu0", "mu1", "sigma0", "sigma1", "shape")
  return(CI_matrix)
}
