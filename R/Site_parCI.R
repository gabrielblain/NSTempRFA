#' Site_parCI
#'
#' @name Site_parCI
#' @param data_site
#' A vector or single column matrix of scaled or divided air temperature data for a single site.
#' @param site_par
#' A 6-column and 1-row `data.frame`. may be obtained from that generated by `best.parms()`.
#'  * 1st column is the mu0 parameter,
#'  * 2nd is the mu1 parameter,
#'  * 3rd is the mu2 parameter,
#'  * 4th is the sigma0 parameter,
#'  * 5th is the sigma1 parameter,
#'  * 6th is the shape parameter
#' @param max_time
#' A single number describing the number of the year that the time-varying parameters
#' should be calculated. For example, if the users need to calculated the parameters
#' for the first year max_time is set to 1 and the 30th year max_time is set to 30.
#' @param n.boots
#' A single number describing the number of copies of the original data sample.
#' Whenever possible n.boots should be set to 999 (its default value),
#' as suggested by Burn (2003) <10.1623/hysj.48.1.25.43485> and
#' Oâ€™Brien and Burn (2014) <10.1016/j.jhydrol.2014.09.041>.
#' @return
#' A matrix containing the 95% confidence intervals (lower and upper bounds)
#' of the time-varying parameter estimates.
#' @export
#' @importFrom stats quantile
#' @importFrom spsUtil quiet
#' @importFrom extRemes fevd
#' @importFrom utils setTxtProgressBar txtProgressBar
#' @examplesIf interactive()
#' data_site <- scaled_data[,2]
#' site_par <- best_sites[1,1:6]
#' max_time <- 30
#' n.boots <- 100
#' Site_parCI(data_site, site_par, max_time, n.boots)
Site_parCI <- function(data_site,site_par,max_time,n.boots){
  data_site <- as.matrix(data_site)
  if (ncol(data_site) != 1) {stop("data_site must be a vector or single column matrix.")}
  if (is.null(n.boots)) {
    n.boots <- 999
  }
  if (n.boots < 100) {stop("n.boots must be larger than 100 and, if possible, equal to 999.")}
  site_par <- as.numeric(site_par)
  par.temporal <- matrix(NA,max_time,3)
  time <- 1L:max_time
  time <- time - mean(time)
  IDD.series <- data_site
  par.temporal[,1] <- site_par[1] + site_par[2] * time + site_par[3] * time^2
  par.temporal[,2] <- site_par[4] + site_par[5] * time
  par.temporal[,3] <-  rep(site_par[6],max_time)
  IDD.series <- (1- par.temporal[,3]*(data_site-par.temporal[,1])/par.temporal[,2])^(1/par.temporal[,3])
  ##################
  all.lines <- n.boots * max_time
  # Preallocate matrix
  IDD.series.boot <- matrix(NA_real_, all.lines, 1)

  # Vectorized resampling
  IDD.series.boot <- as.vector(replicate(n.boots, sample(IDD.series, replace = TRUE)))

  # Preallocate matrices
  site_par.overall.boot <- matrix(NA_real_, n.boots, 6)
  message("This calculation may take a while.")
  pb <- txtProgressBar(min = 0, max = n.boots, style = 3)
  for (r in seq_len(n.boots)) {
    rows <- ((r - 1) * max_time + 1):(r * max_time)
    back.orig <- par.temporal[,1] + (par.temporal[,2] / par.temporal[,3]) * (1 - IDD.series.boot[rows]^par.temporal[,3])
    parameters <- best_model(temperatures=back.orig)
    site_par.overall.boot[r,] <- as.matrix(parameters$atsite.models[1:6])
    setTxtProgressBar(pb, r)
  }
  close(pb)
  # Compute the 95% confidence intervals (row-wise quantiles)
  CI_lower <- apply(site_par.overall.boot, 2, quantile, probs = 0.025, na.rm = TRUE)
  CI_upper <- apply(site_par.overall.boot, 2, quantile, probs = 0.975, na.rm = TRUE)

  # Combine into a matrix for easy visualization
  CI_matrix <- rbind(CI_lower, CI_upper)
  rownames(CI_matrix) <- c("Lower 95% CI", "Upper 95% CI")
  colnames(CI_matrix) <- c("mu0", "mu1", "mu2", "sigma0", "sigma1", "shape")
  return(CI_matrix)
}
