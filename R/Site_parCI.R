#' Site_parCI
#'
#' @name Site_parCI
#' @param atsite_temp
#' A vector or single column matrix of air temperature data subtracted (or not) by its sample mean.
#' @param model
#' A single interger number from 1 to 6 defining the GEV model.
#' May be provided by `best_model()`
#' @param site_par
#' A 6-column and 1-row `data.frame`. may be obtained from that generated by `best.parms()`.
#'  * 1st column is the mu0 parameter,
#'  * 2nd is the mu1 parameter,
#'  * 3rd is the mu2 parameter,
#'  * 4th is the sigma0 parameter,
#'  * 5th is the sigma1 parameter,
#'  * 6th is the shape parameter
#' @param n.boots
#' A single number describing the number of copies of the original data sample.
#' Whenever possible n.boots should be set to 999 (its default value),
#' as suggested by Burn (2003) <10.1623/hysj.48.1.25.43485> and
#' Oâ€™Brien and Burn (2014) <10.1016/j.jhydrol.2014.09.041>.
#' @return
#' A matrix containing the 95% confidence intervals (lower and upper bounds)
#' of the time-varying parameter estimates.
#' @export
#' @importFrom stats quantile
#' @importFrom spsUtil quiet
#' @importFrom extRemes fevd
#' @importFrom utils setTxtProgressBar txtProgressBar
#' @examples
#' atsite_temp <- add_data[,1]
#' model <- 2
#' site_par <- best_sites[1,1:6]
#' n.boots <- 100
#' Site_parCI(atsite_temp,model, site_par, n.boots)
Site_parCI <- function(atsite_temp,model,site_par,n.boots){
  data_site <- as.matrix(atsite_temp)
  if (ncol(data_site) != 1) {stop("data_site must be a vector or single column matrix.")}
  if (is.null(n.boots)) {
    n.boots <- 999
  }
  if (n.boots < 100) {stop("n.boots must be larger than 100 and, if possible, equal to 999.")}
  max_time <- length(data_site)
  if (max_time < 10) {
    stop("Site must have at least 10 years of records. So sorry, we cannot proceed.")
  }
  # Check that site_par is numeric
  if (!is.data.frame(site_par) || !all(sapply(site_par, is.numeric))) {
    stop("Input 'site_par' must be a numeric data frame with 6 columns.")
  }
  if (ncol(site_par) != 6 || nrow(site_par) != 1) {
    stop("Input 'site_par' must have exactly 1 row and 6 columns.")
  }
  site_par <- as.numeric(site_par)
  par.temporal <- matrix(NA,max_time,3)
  scaled <- scale(1L:max_time)
  time <- scaled[,1]
  IDD.series <- data_site
  par.temporal[,1] <- site_par[1] + site_par[2] * time + site_par[3] * time^2
  par.temporal[,2] <- site_par[4] + site_par[5] * time
  par.temporal[,3] <-  rep(site_par[6],max_time)
  IDD.series <- (1- par.temporal[,3]*(data_site-par.temporal[,1])/par.temporal[,2])^(1/par.temporal[,3])
  ##################
  all.lines <- n.boots * max_time
  # Preallocate matrix
  IDD.series.boot <- matrix(NA_real_, all.lines, 1)

  # Vectorized resampling
  IDD.series.boot <- as.vector(replicate(n.boots, sample(IDD.series, replace = TRUE)))

  # Preallocate matrices
  site_par.overall.boot <- matrix(NA_real_, n.boots, 6)
  message("This calculation may take a while.")
  pb <- txtProgressBar(min = 0, max = n.boots, style = 3)
  for (r in seq_len(n.boots)) {
    rows <- ((r - 1) * max_time + 1):(r * max_time)
    back.orig <- par.temporal[,1] + (par.temporal[,2] / par.temporal[,3]) * (1 - IDD.series.boot[rows]^par.temporal[,3])
    parameters <- fit_model(temperatures=back.orig,model=model)
    site_par.overall.boot[r,] <- as.matrix(parameters[1:6])
    setTxtProgressBar(pb, r)
  }
  close(pb)
  # Compute the 95% confidence intervals (row-wise quantiles)
  CI_lower <- apply(site_par.overall.boot, 2, quantile, probs = 0.025, na.rm = TRUE)
  CI_upper <- apply(site_par.overall.boot, 2, quantile, probs = 0.975, na.rm = TRUE)

  # Combine into a matrix for easy visualization
  CI_matrix <- rbind(CI_lower, CI_upper)
  rownames(CI_matrix) <- c("Lower 95% CI", "Upper 95% CI")
  colnames(CI_matrix) <- c("mu0", "mu1", "mu2", "sigma0", "sigma1", "shape")
  return(CI_matrix)
}
